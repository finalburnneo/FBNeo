#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <ctype.h>
#include <algorithm>
#include <vector>

using std::min;
using std::max;

#include "luasav.h"

extern "C" {
#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"
#include "lstate.h"
}

#include "burner.h"
#include "luaengine.h"

#ifdef WIN32
#include <direct.h>
#include <windows.h>
#include "win32/resource.h"
#endif

// can't remember what the best way of doing this is...
#if defined(i386) || defined(__i386) || defined(__i386__) || defined(M_I86) || defined(_M_IX86) || defined(WIN32)
#define IS_LITTLE_ENDIAN
#endif

#undef delete

// push a value's bytes onto the output stack
template <typename T>
void PushBinaryItem(T item, std::vector<unsigned char>& output)
{
	auto buf = static_cast<unsigned char*>(&item);
#ifdef IS_LITTLE_ENDIAN
	for (int i = sizeof(T); i; --i)
		output.push_back(*buf++);
#else
	int vecsize = output.size();
	for(int i = sizeof(T); i; i--)
		output.insert(output.begin() + vecsize, *buf++);
#endif
}

// read a value from the byte stream and advance the stream by its size
template <typename T>
T AdvanceByteStream(const unsigned char*& data, unsigned int& remaining)
{
#ifdef IS_LITTLE_ENDIAN
	T rv = *static_cast<T*>(data);
	data += sizeof(T);
#else
	T rv; unsigned char* rvptr = (unsigned char*)&rv;
	for(int i = sizeof(T)-1; i>=0; i--)
		rvptr[i] = *data++;
#endif
	remaining -= sizeof(T);
	return rv;
}

// advance the byte stream by a certain size without reading a value
void AdvanceByteStream(const unsigned char*& data, unsigned int& remaining, int amount)
{
	data += amount;
	remaining -= amount;
}

#define LUAEXT_TLONG		30 // 0x1E // 4-byte signed integer
#define LUAEXT_TUSHORT		31 // 0x1F // 2-byte unsigned integer
#define LUAEXT_TSHORT		32 // 0x20 // 2-byte signed integer
#define LUAEXT_TBYTE		33 // 0x21 // 1-byte unsigned integer
#define LUAEXT_TNILS		34 // 0x22 // multiple nils represented by a 4-byte integer (warning: becomes multiple stack entities)


#define LUAEXT_TTABLE		0x40 // 0x40 through 0x4F // tables of different sizes:
#define LUAEXT_BITS_1A		0x01 // size of array part fits in a 1-byte unsigned integer
#define LUAEXT_BITS_2A		0x02 // size of array part fits in a 2-byte unsigned integer
#define LUAEXT_BITS_4A		0x03 // size of array part fits in a 4-byte unsigned integer
#define LUAEXT_BITS_1H		0x04 // size of hash part fits in a 1-byte unsigned integer
#define LUAEXT_BITS_2H		0x08 // size of hash part fits in a 2-byte unsigned integer
#define LUAEXT_BITS_4H		0x0C // size of hash part fits in a 4-byte unsigned integer
#define BITMATCH(x,y) (((x) & (y)) == (y))

static void PushNils(std::vector<unsigned char>& output, int& nilcount)
{
	int count = nilcount;
	nilcount = 0;

	static constexpr int minNilsWorthEncoding = 6; // because a LUAEXT_TNILS entry is 5 bytes

	if (count < minNilsWorthEncoding)
	{
		for (int i = 0; i < count; i++)
			output.push_back(LUA_TNIL);
	}
	else
	{
		output.push_back(LUAEXT_TNILS);
		PushBinaryItem<UINT32>(count, output);
	}
}

static std::vector<const void*> s_tableAddressStack;
// prevents infinite recursion of a table within a table (when cycle is found, print something like table:parent)
static std::vector<const void*> s_metacallStack;
// prevents infinite recursion if something's __tostring returns another table that contains that something (when cycle is found, print the inner result without using __tostring)

static void LuaStackToBinaryConverter(lua_State* L, int i, std::vector<unsigned char>& output)
{
	int type = lua_type(L, i);

	// the first byte of every serialized item says what Lua type it is
	output.push_back(type & 0xFF);

	switch (type)
	{
	default:
		{
			char errmsg[1024];
			sprintf(errmsg, "values of type \"%s\" are not allowed to be returned from registered save functions.\r\n",
			        luaL_typename(L, i));
			VidSNewTinyMsg(_AtoT(errmsg));
		}
		break;
	case LUA_TNIL:
		// no information necessary beyond the type
		break;
	case LUA_TBOOLEAN:
		// serialize as 0 or 1
		output.push_back(lua_toboolean(L, i));
		break;
	case LUA_TSTRING:
		// serialize as a 0-terminated string of characters
		{
			const char* str = lua_tostring(L, i);
			while (*str)
				output.push_back(*str++);
			output.push_back('\0');
		}
		break;
	case LUA_TNUMBER:
		{
			double num = lua_tonumber(L, i);
			INT32 inum = static_cast<INT32>(lua_tointeger(L, i));
			if (num != inum)
			{
				PushBinaryItem(num, output);
			}
			else
			{
				if ((inum & ~0xFF) == 0)
					type = LUAEXT_TBYTE;
				else if (static_cast<UINT16>(inum & 0xFFFF) == inum)
					type = LUAEXT_TUSHORT;
				else if (static_cast<INT16>(inum & 0xFFFF) == inum)
					type = LUAEXT_TSHORT;
				else
					type = LUAEXT_TLONG;
				output.back() = type;
				switch (type)
				{
				case LUAEXT_TLONG:
					PushBinaryItem<INT32>(inum, output);
					break;
				case LUAEXT_TUSHORT:
					PushBinaryItem<UINT16>(static_cast<UINT16>(inum), output);
					break;
				case LUAEXT_TSHORT:
					PushBinaryItem<INT16>(static_cast<INT16>(inum), output);
					break;
				case LUAEXT_TBYTE:
					output.push_back(static_cast<UINT8>(inum));
					break;
				}
			}
		}
		break;
	case LUA_TTABLE:
		// serialize as a type that describes how many bytes are used for storing the counts,
		// followed by the number of array entries if any, then the number of hash entries if any,
		// then a Lua value per array entry, then a (key,value) pair of Lua values per hashed entry
		// note that the structure of table references are not faithfully serialized (yet)
		{
			int outputTypeIndex = output.size() - 1;
			int arraySize = 0;
			int hashSize = 0;

			if (lua_checkstack(L, 4) && std::find(s_tableAddressStack.begin(), s_tableAddressStack.end(),
			                                      lua_topointer(L, i)) == s_tableAddressStack.end())
			{
				s_tableAddressStack.push_back(lua_topointer(L, i));
				//				struct Scope { ~Scope(){ s_tableAddressStack.pop_back(); } } scope;

				bool wasnil = false;
				int nilcount = 0;
				arraySize = lua_objlen(L, i);
				int arrayValIndex = lua_gettop(L) + 1;
				for (int j = 1; j <= arraySize; j++)
				{
					lua_rawgeti(L, i, j);
					bool isnil = lua_isnil(L, arrayValIndex);
					if (isnil)
						nilcount++;
					else
					{
						if (wasnil)
							PushNils(output, nilcount);
						LuaStackToBinaryConverter(L, arrayValIndex, output);
					}
					lua_pop(L, 1);
					wasnil = isnil;
				}
				if (wasnil)
					PushNils(output, nilcount);

				if (arraySize)
					lua_pushinteger(L, arraySize); // before first key
				else
					lua_pushnil(L); // before first key

				int keyIndex = lua_gettop(L);
				int valueIndex = keyIndex + 1;
				while (lua_next(L, i))
				{
					//					assert(lua_type(L, keyIndex) && "nil key in Lua table, impossible");
					//					assert(lua_type(L, valueIndex) && "nil value in Lua table, impossible");
					LuaStackToBinaryConverter(L, keyIndex, output);
					LuaStackToBinaryConverter(L, valueIndex, output);
					lua_pop(L, 1);
					hashSize++;
				}
			}

			int outputType = LUAEXT_TTABLE;
			if (arraySize & 0xFFFF0000)
				outputType |= LUAEXT_BITS_4A;
			else if (arraySize & 0xFF00)
				outputType |= LUAEXT_BITS_2A;
			else if (arraySize & 0xFF)
				outputType |= LUAEXT_BITS_1A;
			if (hashSize & 0xFFFF0000)
				outputType |= LUAEXT_BITS_4H;
			else if (hashSize & 0xFF00)
				outputType |= LUAEXT_BITS_2H;
			else if (hashSize & 0xFF)
				outputType |= LUAEXT_BITS_1H;
			output[outputTypeIndex] = outputType;

			int insertIndex = outputTypeIndex;
			if (BITMATCH(outputType, LUAEXT_BITS_4A) || BITMATCH(outputType, LUAEXT_BITS_2A) || BITMATCH(
				outputType, LUAEXT_BITS_1A))
				output.insert(output.begin() + (++insertIndex), arraySize & 0xFF);
			if (BITMATCH(outputType, LUAEXT_BITS_4A) || BITMATCH(outputType, LUAEXT_BITS_2A))
				output.insert(output.begin() + (++insertIndex), (arraySize & 0xFF00) >> 8);
			if (BITMATCH(outputType, LUAEXT_BITS_4A))
				output.insert(output.begin() + (++insertIndex), (arraySize & 0x00FF0000) >> 16),
					output.insert(output.begin() + (++insertIndex), (arraySize & 0xFF000000) >> 24);
			if (BITMATCH(outputType, LUAEXT_BITS_4H) || BITMATCH(outputType, LUAEXT_BITS_2H) || BITMATCH(
				outputType, LUAEXT_BITS_1H))
				output.insert(output.begin() + (++insertIndex), hashSize & 0xFF);
			if (BITMATCH(outputType, LUAEXT_BITS_4H) || BITMATCH(outputType, LUAEXT_BITS_2H))
				output.insert(output.begin() + (++insertIndex), (hashSize & 0xFF00) >> 8);
			if (BITMATCH(outputType, LUAEXT_BITS_4H))
				output.insert(output.begin() + (++insertIndex), (hashSize & 0x00FF0000) >> 16),
					output.insert(output.begin() + (++insertIndex), (hashSize & 0xFF000000) >> 24);
		}
		break;
	}
}


// complements LuaStackToBinaryConverter
void BinaryToLuaStackConverter(lua_State* L, const unsigned char*& data, unsigned int& remaining)
{
	//	assert(s_dbg_dataSize - (data - s_dbg_dataStart) == remaining);

	unsigned char type = AdvanceByteStream<unsigned char>(data, remaining);

	switch (type)
	{
	default:
		{
			char errmsg[1024];
			if (type <= 10 && type != LUA_TTABLE)
				sprintf(errmsg,
				        "values of type \"%s\" are not allowed to be loaded into registered load functions. The save state's Lua save data file might be corrupted.\r\n",
				        lua_typename(L, type));
			else
				sprintf(errmsg, "The save state's Lua save data file seems to be corrupted.\r\n");
			VidSNewTinyMsg(_AtoT(errmsg));
		}
		break;
	case LUA_TNIL:
		lua_pushnil(L);
		break;
	case LUA_TBOOLEAN:
		lua_pushboolean(L, AdvanceByteStream<UINT8>(data, remaining));
		break;
	case LUA_TSTRING:
		lua_pushstring(L, (const char*)data);
		AdvanceByteStream(data, remaining, strlen((const char*)data) + 1);
		break;
	case LUA_TNUMBER:
		lua_pushnumber(L, AdvanceByteStream<double>(data, remaining));
		break;
	case LUAEXT_TLONG:
		lua_pushinteger(L, AdvanceByteStream<INT32>(data, remaining));
		break;
	case LUAEXT_TUSHORT:
		lua_pushinteger(L, AdvanceByteStream<UINT16>(data, remaining));
		break;
	case LUAEXT_TSHORT:
		lua_pushinteger(L, AdvanceByteStream<INT16>(data, remaining));
		break;
	case LUAEXT_TBYTE:
		lua_pushinteger(L, AdvanceByteStream<UINT8>(data, remaining));
		break;
	case LUAEXT_TTABLE:
	case LUAEXT_TTABLE | LUAEXT_BITS_1A:
	case LUAEXT_TTABLE | LUAEXT_BITS_2A:
	case LUAEXT_TTABLE | LUAEXT_BITS_4A:
	case LUAEXT_TTABLE | LUAEXT_BITS_1H:
	case LUAEXT_TTABLE | LUAEXT_BITS_2H:
	case LUAEXT_TTABLE | LUAEXT_BITS_4H:
	case LUAEXT_TTABLE | LUAEXT_BITS_1A | LUAEXT_BITS_1H:
	case LUAEXT_TTABLE | LUAEXT_BITS_2A | LUAEXT_BITS_1H:
	case LUAEXT_TTABLE | LUAEXT_BITS_4A | LUAEXT_BITS_1H:
	case LUAEXT_TTABLE | LUAEXT_BITS_1A | LUAEXT_BITS_2H:
	case LUAEXT_TTABLE | LUAEXT_BITS_2A | LUAEXT_BITS_2H:
	case LUAEXT_TTABLE | LUAEXT_BITS_4A | LUAEXT_BITS_2H:
	case LUAEXT_TTABLE | LUAEXT_BITS_1A | LUAEXT_BITS_4H:
	case LUAEXT_TTABLE | LUAEXT_BITS_2A | LUAEXT_BITS_4H:
	case LUAEXT_TTABLE | LUAEXT_BITS_4A | LUAEXT_BITS_4H:
		{
			unsigned int arraySize = 0;
			if (BITMATCH(type, LUAEXT_BITS_4A) || BITMATCH(type, LUAEXT_BITS_2A) || BITMATCH(type, LUAEXT_BITS_1A))
				arraySize |= AdvanceByteStream<UINT8>(data, remaining);
			if (BITMATCH(type, LUAEXT_BITS_4A) || BITMATCH(type, LUAEXT_BITS_2A))
				arraySize |= static_cast<UINT16>(AdvanceByteStream<UINT8>(data, remaining)) << 8;
			if (BITMATCH(type, LUAEXT_BITS_4A))
				arraySize |= static_cast<UINT32>(AdvanceByteStream<UINT8>(data, remaining)) << 16,
					arraySize |= static_cast<UINT32>(AdvanceByteStream<UINT8>(data, remaining)) << 24;

			unsigned int hashSize = 0;
			if (BITMATCH(type, LUAEXT_BITS_4H) || BITMATCH(type, LUAEXT_BITS_2H) || BITMATCH(type, LUAEXT_BITS_1H))
				hashSize |= AdvanceByteStream<UINT8>(data, remaining);
			if (BITMATCH(type, LUAEXT_BITS_4H) || BITMATCH(type, LUAEXT_BITS_2H))
				hashSize |= static_cast<UINT16>(AdvanceByteStream<UINT8>(data, remaining)) << 8;
			if (BITMATCH(type, LUAEXT_BITS_4H))
				hashSize |= static_cast<UINT32>(AdvanceByteStream<UINT8>(data, remaining)) << 16,
					hashSize |= static_cast<UINT32>(AdvanceByteStream<UINT8>(data, remaining)) << 24;

			lua_checkstack(L, 8);

			lua_createtable(L, arraySize, hashSize);

			unsigned int n = 1;
			while (n <= arraySize)
			{
				if (*data == LUAEXT_TNILS)
				{
					AdvanceByteStream(data, remaining, 1);
					n += AdvanceByteStream<UINT32>(data, remaining);
				}
				else
				{
					BinaryToLuaStackConverter(L, data, remaining); // push value
					lua_rawseti(L, -2, n); // table[n] = value
					n++;
				}
			}

			for (unsigned int h = 1; h <= hashSize; h++)
			{
				BinaryToLuaStackConverter(L, data, remaining); // push key
				BinaryToLuaStackConverter(L, data, remaining); // push value
				lua_rawset(L, -3); // table[key] = value
			}
		}
		break;
	}
}

static constexpr unsigned char luaBinaryMajorVersion = 9;
static constexpr unsigned char luaBinaryMinorVersion = 1;

unsigned char* LuaStackToBinary(lua_State* L, unsigned int& size)
{
	int n = lua_gettop(L);
	if (n == 0)
		return nullptr;

	std::vector<unsigned char> output;
	output.push_back(luaBinaryMajorVersion);
	output.push_back(luaBinaryMinorVersion);

	for (int i = 1; i <= n; i++)
		LuaStackToBinaryConverter(L, i, output);

	auto rv = new unsigned char [output.size()];
	memcpy(rv, &output.front(), output.size());
	size = output.size();
	return rv;
}

void BinaryToLuaStack(lua_State* L, const unsigned char* data, unsigned int size, unsigned int itemsToLoad)
{
	unsigned char major = *data++;
	unsigned char minor = *data++;
	size -= 2;
	if (luaBinaryMajorVersion != major || luaBinaryMinorVersion != minor)
		return;

	while (size > 0 && itemsToLoad > 0)
	{
		BinaryToLuaStackConverter(L, data, size);
		itemsToLoad--;
	}
}

// saves Lua stack into a record and pops it
void LuaSaveData::SaveRecord(lua_State* L, unsigned int key)
{
	if (!L)
		return;

	auto cur = new Record();
	cur->key = key;
	cur->data = LuaStackToBinary(L, cur->size);
	cur->next = nullptr;

	lua_settop(L, 0);

	if (cur->size <= 0)
	{
		delete cur;
		return;
	}

	Record* last = recordList;
	while (last && last->next)
		last = last->next;
	if (last)
		last->next = cur;
	else
		recordList = cur;
}

// pushes a record's data onto the Lua stack
void LuaSaveData::LoadRecord(struct lua_State* L, unsigned int key, unsigned int itemsToLoad) const
{
	if (!L)
		return;

	Record* cur = recordList;
	while (cur)
	{
		if (cur->key == key)
		{
			//			s_dbg_dataStart = cur->data;
			//			s_dbg_dataSize = cur->size;
			BinaryToLuaStack(L, cur->data, cur->size, itemsToLoad);
			return;
		}
		cur = cur->next;
	}
}

// saves part of the Lua stack (at the given index) into a record and does NOT pop anything
void LuaSaveData::SaveRecordPartial(struct lua_State* L, unsigned int key, int idx)
{
	if (!L)
		return;

	if (idx < 0)
		idx += lua_gettop(L) + 1;

	auto cur = new Record();
	cur->key = key;
	cur->next = nullptr;

	if (idx <= lua_gettop(L))
	{
		std::vector<unsigned char> output;
		output.push_back(luaBinaryMajorVersion);
		output.push_back(luaBinaryMinorVersion);

		LuaStackToBinaryConverter(L, idx, output);

		auto rv = new unsigned char [output.size()];
		memcpy(rv, &output.front(), output.size());
		cur->size = output.size();
		cur->data = rv;
	}

	if (cur->size <= 0)
	{
		delete cur;
		return;
	}

	Record* last = recordList;
	while (last && last->next)
		last = last->next;
	if (last)
		last->next = cur;
	else
		recordList = cur;
}

void fwriteint(unsigned int value, FILE* file)
{
	for (int i = 0; i < 4; i++)
	{
		int w = value & 0xFF;
		fwrite(&w, 1, 1, file);
		value >>= 8;
	}
}

void freadint(unsigned int& value, FILE* file)
{
	int rv = 0;
	for (int i = 0; i < 4; i++)
	{
		int r = 0;
		fread(&r, 1, 1, file);
		rv |= r << (i * 8);
	}
	value = rv;
}

// writes all records to an already-open file
void LuaSaveData::ExportRecords(void* fileV) const
{
	auto file = static_cast<FILE*>(fileV);
	if (!file)
		return;

	Record* cur = recordList;
	while (cur)
	{
		fwriteint(cur->key, file);
		fwriteint(cur->size, file);
		fwrite(cur->data, cur->size, 1, file);
		cur = cur->next;
	}
}

// reads records from an already-open file
void LuaSaveData::ImportRecords(void* fileV)
{
	auto file = static_cast<FILE*>(fileV);
	if (!file)
		return;

	ClearRecords();

	Record rec;
	Record* cur = &rec;
	Record* last = nullptr;
	while (true)
	{
		freadint(cur->key, file);
		freadint(cur->size, file);

		if (feof(file) || ferror(file))
			break;

		cur->data = new unsigned char [cur->size];
		fread(cur->data, cur->size, 1, file);

		auto next = new Record();
		memcpy(next, cur, sizeof(Record));
		next->next = nullptr;

		if (last)
			last->next = next;
		else
			recordList = next;
		last = next;
	}
}

void LuaSaveData::ClearRecords()
{
	Record* cur = recordList;
	while (cur)
	{
		Record* del = cur;
		cur = cur->next;

		delete[] del->data;
		delete del;
	}

	recordList = nullptr;
}


void CallRegisteredLuaSaveFunctions(const char* savestateNumber, LuaSaveData& saveData)
{
	lua_State* L = FBA_GetLuaState();
	if (L)
	{
		lua_settop(L, 0);
		lua_getfield(L, LUA_REGISTRYINDEX, LUA_SAVE_CALLBACK_STRING);

		if (lua_isfunction(L, -1))
		{
			lua_pushstring(L, savestateNumber);
			int ret = lua_pcall(L, 1, LUA_MULTRET, 0);
			if (ret != 0)
			{
				// This is grounds for trashing the function
				lua_pushnil(L);
				lua_setfield(L, LUA_REGISTRYINDEX, LUA_SAVE_CALLBACK_STRING);
#ifdef WIN32
				MessageBoxA(hScrnWnd, lua_tostring(L, -1), "Lua Error in SAVE function", MB_OK);
#else
				fprintf(stderr, "Lua error in registersave function: %s\n", lua_tostring(L, -1));
#endif
			}
			saveData.SaveRecord(L, LUA_DATARECORDKEY);
		}
		else
		{
			lua_pop(L, 1);
		}
	}
}


void CallRegisteredLuaLoadFunctions(const char* savestateNumber, const LuaSaveData& saveData)
{
	lua_State* L = FBA_GetLuaState();
	if (L)
	{
		lua_settop(L, 0);
		lua_getfield(L, LUA_REGISTRYINDEX, LUA_LOAD_CALLBACK_STRING);

		if (lua_isfunction(L, -1))
		{
			// since the scriptdata can be very expensive to load
			// (e.g. the registered save function returned some huge tables)
			// check the number of parameters the registered load function expects
			// and don't bother loading the parameters it wouldn't receive anyway
			int numParamsExpected = (L->top - 1)->value.gc->cl.l.p->numparams;
			// NOTE: if this line crashes, that means your Lua headers are out of sync with your Lua lib
			if (numParamsExpected) numParamsExpected--; // minus one for the savestate number we always pass in

			int prevGarbage = lua_gc(L, LUA_GCCOUNT, 0);

			lua_pushstring(L, savestateNumber);
			saveData.LoadRecord(L, LUA_DATARECORDKEY, numParamsExpected);
			int n = lua_gettop(L) - 1;

			int ret = lua_pcall(L, n, 0, 0);
			if (ret != 0)
			{
				// This is grounds for trashing the function
				lua_pushnil(L);
				lua_setfield(L, LUA_REGISTRYINDEX, LUA_LOAD_CALLBACK_STRING);
#ifdef WIN32
				MessageBoxA(hScrnWnd, lua_tostring(L, -1), "Lua Error in LOAD function", MB_OK);
#else
				fprintf(stderr, "Lua error in registerload function: %s\n", lua_tostring(L, -1));
#endif
			}
			else
			{
				int newGarbage = lua_gc(L, LUA_GCCOUNT, 0);
				if (newGarbage - prevGarbage > 50)
				{
					// now seems to be a very good time to run the garbage collector
					// it might take a while now but that's better than taking 10 whiles 9 loads from now
					lua_gc(L, LUA_GCCOLLECT, 0);
				}
			}
		}
		else
		{
			lua_pop(L, 1);
		}
	}
}
